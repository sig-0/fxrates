// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

// A single observed exchange rate data point.
type ExchangeRate struct {
	// Effective date/time for which this rate applies.
	AsOf Time `json:"as_of"`
	// Time when this record was fetched/observed by the system.
	FetchedAt Time `json:"fetched_at"`
	// Base currency (ISO 4217), e.g. "USD".
	Base string `json:"base"`
	// Target currency (ISO 4217), e.g. "VES".
	Target string `json:"target"`
	// Rate classification (MID/BUY/SELL).
	RateType RateType `json:"rate_type"`
	// Provider/source identifier, e.g. "BCV".
	Source string `json:"source"`
	// Quoted rate from base -> target.
	Rate float64 `json:"rate"`
}

// A paginated collection of exchange rates.
type ExchangeRatePage struct {
	// Current page of results.
	Results []*ExchangeRate `json:"results"`
	// Total number of matching results before pagination.
	Total int32 `json:"total"`
}

type Query struct {
}

// Classifies the kind of rate being reported.
type RateType string

const (
	// Mid-market rate.
	RateTypeMid RateType = "MID"
	// Buy rate (what the provider/bank buys at).
	RateTypeBuy RateType = "BUY"
	// Sell rate (what the provider/bank sells at).
	RateTypeSell RateType = "SELL"
)

var AllRateType = []RateType{
	RateTypeMid,
	RateTypeBuy,
	RateTypeSell,
}

func (e RateType) IsValid() bool {
	switch e {
	case RateTypeMid, RateTypeBuy, RateTypeSell:
		return true
	}
	return false
}

func (e RateType) String() string {
	return string(e)
}

func (e *RateType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RateType", str)
	}
	return nil
}

func (e RateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RateType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RateType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
