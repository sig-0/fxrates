package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/sig-0/fxrates/server/graph/model"
	"github.com/sig-0/fxrates/storage/types"
)

// Rates is the resolver for the rates field.
func (r *queryResolver) Rates(ctx context.Context, base string, target *string, asOf *model.Time, source *string, typeArg *model.RateType, limit *int32, offset *int32) (*model.ExchangeRatePage, error) {
	b, err := parseCurrencySymbol(base)
	if err != nil {
		return nil, err
	}

	var tgt *types.Currency
	if target != nil {
		t, err := parseCurrencySymbol(*target)
		if err != nil {
			return nil, err
		}
		tgt = &t
	}

	lim, off, err := parseLimitOffset(limit, offset)
	if err != nil {
		return nil, err
	}

	src, rt, err := parseSourceAndType(source, typeArg)
	if err != nil {
		return nil, err
	}

	q := &types.RateQuery{
		Base:     b,
		Target:   tgt,
		Source:   src,
		RateType: rt,
		Limit:    lim,
		Offset:   off,
	}

	page, err := r.Resolver.Storage.RateAsOf(ctx, q, parseAsOf(asOf))
	if err != nil {
		return nil, fmt.Errorf("unable to fetch rates: %w", err)
	}

	out := make([]*model.ExchangeRate, 0, len(page.Results))
	for _, it := range page.Results {
		out = append(out, toModelExchangeRate(it))
	}

	return &model.ExchangeRatePage{
		Results: out,
		Total:   clampTotalToInt32(page.Total),
	}, nil
}

// Sources is the resolver for the sources field.
func (r *queryResolver) Sources(ctx context.Context) ([]string, error) {
	items, err := r.Resolver.Storage.ListSources(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to fetch sources: %w", err)
	}

	out := make([]string, 0, len(items))
	for _, s := range items {
		out = append(out, s.String())
	}

	return out, nil
}

// Currencies is the resolver for the currencies field.
func (r *queryResolver) Currencies(ctx context.Context) ([]string, error) {
	items, err := r.Resolver.Storage.ListCurrencies(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to fetch currencies: %w", err)
	}

	out := make([]string, 0, len(items))
	for _, c := range items {
		out = append(out, c.String())
	}

	return out, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
