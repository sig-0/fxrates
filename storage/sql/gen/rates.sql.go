// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rates.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const rateAsOf = `-- name: RateAsOf :one
SELECT id, base, target, rate, rate_type, source, as_of, fetched_at
FROM exchange_rates
WHERE base = $1
  AND target = $2
  AND source = $3
  AND rate_type = $4
  AND as_of <= $5
ORDER BY as_of DESC
LIMIT 1
`

type RateAsOfParams struct {
	Base     string
	Target   string
	Source   string
	RateType string
	AsOf     pgtype.Timestamptz
}

func (q *Queries) RateAsOf(ctx context.Context, arg RateAsOfParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, rateAsOf,
		arg.Base,
		arg.Target,
		arg.Source,
		arg.RateType,
		arg.AsOf,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.Base,
		&i.Target,
		&i.Rate,
		&i.RateType,
		&i.Source,
		&i.AsOf,
		&i.FetchedAt,
	)
	return i, err
}

const ratesInRange = `-- name: RatesInRange :many
SELECT
  exchange_rates.id, exchange_rates.base, exchange_rates.target, exchange_rates.rate, exchange_rates.rate_type, exchange_rates.source, exchange_rates.as_of, exchange_rates.fetched_at,
  COUNT(*) OVER()::bigint AS total
FROM exchange_rates
WHERE base = $1
  AND target = $2
  AND source = $3
  AND rate_type = $4
  AND as_of >= $5
  AND as_of <= $6
ORDER BY as_of ASC
LIMIT $7
OFFSET $8::bigint
`

type RatesInRangeParams struct {
	Base     string
	Target   string
	Source   string
	RateType string
	AsOf     pgtype.Timestamptz
	AsOf_2   pgtype.Timestamptz
	Limit    int32
	Column8  int64
}

type RatesInRangeRow struct {
	ID        int64
	Base      string
	Target    string
	Rate      pgtype.Numeric
	RateType  string
	Source    string
	AsOf      pgtype.Timestamptz
	FetchedAt pgtype.Timestamptz
	Total     int64
}

func (q *Queries) RatesInRange(ctx context.Context, arg RatesInRangeParams) ([]RatesInRangeRow, error) {
	rows, err := q.db.Query(ctx, ratesInRange,
		arg.Base,
		arg.Target,
		arg.Source,
		arg.RateType,
		arg.AsOf,
		arg.AsOf_2,
		arg.Limit,
		arg.Column8,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RatesInRangeRow
	for rows.Next() {
		var i RatesInRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Base,
			&i.Target,
			&i.Rate,
			&i.RateType,
			&i.Source,
			&i.AsOf,
			&i.FetchedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveExchangeRate = `-- name: SaveExchangeRate :exec
INSERT INTO exchange_rates (
  base, target, rate, rate_type, source, as_of, fetched_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
`

type SaveExchangeRateParams struct {
	Base      string
	Target    string
	Rate      pgtype.Numeric
	RateType  string
	Source    string
	AsOf      pgtype.Timestamptz
	FetchedAt pgtype.Timestamptz
}

func (q *Queries) SaveExchangeRate(ctx context.Context, arg SaveExchangeRateParams) error {
	_, err := q.db.Exec(ctx, saveExchangeRate,
		arg.Base,
		arg.Target,
		arg.Rate,
		arg.RateType,
		arg.Source,
		arg.AsOf,
		arg.FetchedAt,
	)
	return err
}
